<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>案例4</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../reveal.js/css/theme/beige.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '../reveal.js/css/print/pdf.css' : '../reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  <!--[if lt IE 9]>
  <script src="../reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">
	
	<section>
<h2 id="案例4使用残差分析进行离心泵故障诊断"><span id="jump3">案例4：使用残差分析进行离心泵故障诊断</span></h2>
</section>
<section align=left>
<p>本案例延续了<a href="example3.html" target="_blank">案例3</a>中基于稳态实验的故障诊断方法的情况，所不同的是本案例中的水泵运行于各种不同工况中，即转速不再限于2900 RPM</p>
</section>
<section align=left>
<h4 id="第一步多速泵系统建模基于残差分析的诊断"><strong>第一步：多速泵系统建模——基于残差分析的诊断</strong></h4>
<section>
<p>当水泵运行于转速变化快且变化范围大时，稳态泵扬程和扭矩方程不再能得到精确结果。此时，摩擦和其他损失的影响变得更加明显，而模型参数又依赖水泵转速。可行的方案便是建立一个黑盒模型，模型参数不必具有物理意义。该模型作为水泵已知行为的模拟器，模型的输出为从对应的测量信号中提取得到的残差。残差的特性，如均值、方差和功率被用来区分正常和故障操作工况</p>
<p>由如下系统简图可知，使用静态泵扬程方程，动态泵-管道系统方程，可以计算出图中标红的4种残差</p>
<p><img data-src="..\HIDesign\systemFlow.png" /></p>
<p>系统图中四个灰色模型的表示如下：</p>
<ul>
<li>静态泵模型：<span class="math inline"><em>Δ</em><em>p̂</em>(<em>t</em>) = <em>θ</em><sub>1</sub><em>ω</em><sup>2</sup>(<em>t</em>) + <em>θ</em><sub>2</sub><em>ω</em>(<em>t</em>)</span></li>
<li>动态管道模型：<span class="math inline">$\hat Q(t)=\theta_3+\theta_4\sqrt{\Delta p(t)}+\theta_5\hat Q(t-1)$</span></li>
<li>动态泵-管道模型：<span class="math inline">$\hat{\hat Q}(t)=\theta_3+\theta_4\sqrt{\Delta\hat p(t)}+\theta_5\hat{\hat Q}(t-1)$</span></li>
<li>动态逆泵模型：<span class="math inline"><em>M̂</em><sub><em>m</em><em>o</em><em>t</em><em>o</em><em>r</em></sub>(<em>t</em>) = <em>θ</em><sub>6</sub> + <em>θ</em><sub>7</sub><em>ω</em>(<em>t</em>) + <em>θ</em><sub>8</sub><em>ω</em>(<em>t</em> − 1) + <em>θ</em><sub>9</sub><em>ω</em><sup>2</sup>(<em>t</em>) + <em>θ</em><sub>10</sub><em>M̂</em><sub><em>m</em><em>o</em><em>t</em><em>o</em><em>r</em></sub>(<em>t</em> − 1)</span></li>
</ul>
<p>模型参数<span class="math inline"><em>θ</em><sub>1</sub>, ..., <em>θ</em><sub>10</sub></span>与水泵转速相关。</p>
</section>
<section>
<p>本案例中，模型参数将通过分段线性估计方法得到，转速区间分为以下3个档：</p>
<ol type="1">
<li><span class="math inline"><em>ω</em> ≤ 900<em>R</em><em>P</em><em>M</em></span></li>
<li><span class="math inline">900 &lt; <em>ω</em> ≤ 1500<em>R</em><em>P</em><em>M</em></span></li>
<li><span class="math inline"><em>ω</em> &gt; 1500<em>R</em><em>P</em><em>M</em></span></li>
</ol>
<p>正常情况下，水泵运行于由闭环控制器控制的0-3000 RPM参考转速区间内，该参考转速输入属于修正伪随机位序列信号。电机扭矩、泵扭矩、泵转速和压强数据在10 Hz的采样频率下采集</p>
</section>
<section>
<p>以下代码用于加载测量得到的这些信号并且画出参考转速和实际转速的图像：</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb65-1" data-line-number="1">load DynamicOperationData</a>
<a class="sourceLine" id="cb65-2" data-line-number="2">figure</a>
<a class="sourceLine" id="cb65-3" data-line-number="3">plot(t, RefSpeed, t, w)</a>
<a class="sourceLine" id="cb65-4" data-line-number="4">xlabel(<span class="st">&#39;Time (s)&#39;</span>)</a>
<a class="sourceLine" id="cb65-5" data-line-number="5">ylabel(<span class="st">&#39;Pump Speed (RPM)&#39;</span>)</a>
<a class="sourceLine" id="cb65-6" data-line-number="6">legend(<span class="st">&#39;Reference&#39;</span>,<span class="st">&#39;Actual&#39;</span>)</a></code></pre></div>
<p align=center><img src="..\HIDesign\pumpSpeed.png" style="zoom:100%;" /></p>
<p>以下代码定义泵转速划分的三种区间范围：</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb66-1" data-line-number="1">I1 = w&lt;=<span class="fl">900</span>;            <span class="co">% 第一个区间</span></a>
<a class="sourceLine" id="cb66-2" data-line-number="2">I2 = w&gt;<span class="fl">900</span> &amp; w&lt;=<span class="fl">1500</span>;   <span class="co">% 第二个区间</span></a>
<a class="sourceLine" id="cb66-3" data-line-number="3">I3 = w&gt;<span class="fl">1500</span>;            <span class="co">% 第三个区间</span></a></code></pre></div>
</section>
</section>
<section align=left>
<h4 id="第二步模型识别"><strong>第二步：模型识别</strong></h4>
<section>
<h4 id="静态泵模型识别"><strong>静态泵模型识别</strong></h4>
<p>使用泵转速<span class="math inline"><em>ω</em>(<em>t</em>)</span>和压差<span class="math inline"><em>Δ</em><em>p</em>(<em>t</em>)</span>作为静态泵模型方程的输入输出得到模型参数<span class="math inline"><em>θ</em><sub>1</sub></span>和<span class="math inline"><em>θ</em><sub>2</sub></span>的估计值，此处函数<code>staticPumpEst</code>用来执行估计过程：</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb67-1" data-line-number="1">function [x1, x2, dpest] = staticPumpEst(w, dp, I)</a>
<a class="sourceLine" id="cb67-2" data-line-number="2"><span class="co">% 该方法用来估计静态泵方程（根据方程用矩阵形式反算参数）在不同泵转速设定下的方程参数</span></a>
<a class="sourceLine" id="cb67-3" data-line-number="3"><span class="co">% I: 转速区间设定的索引</span></a>
<a class="sourceLine" id="cb67-4" data-line-number="4"></a>
<a class="sourceLine" id="cb67-5" data-line-number="5">w1 = [<span class="fl">0</span>; w(I)];</a>
<a class="sourceLine" id="cb67-6" data-line-number="6">dp1 = [<span class="fl">0</span>; dp(I)];</a>
<a class="sourceLine" id="cb67-7" data-line-number="7">R1 = [w1.^<span class="fl">2</span> w1];</a>
<a class="sourceLine" id="cb67-8" data-line-number="8">x = pinv(R1)*dp1;</a>
<a class="sourceLine" id="cb67-9" data-line-number="9">x1 = x(<span class="fl">1</span>);  </a>
<a class="sourceLine" id="cb67-10" data-line-number="10">x2 = x(<span class="fl">2</span>);  </a>
<a class="sourceLine" id="cb67-11" data-line-number="11"></a>
<a class="sourceLine" id="cb67-12" data-line-number="12">dpest = R1(<span class="fl">2</span>:end,:)*x;</a>
<a class="sourceLine" id="cb67-13" data-line-number="13">end</a></code></pre></div>
</section>
<section>
<div class="sourceCode" id="cb68"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb68-1" data-line-number="1">th1 = zeros(<span class="fl">3</span>,<span class="fl">1</span>);  </a>
<a class="sourceLine" id="cb68-2" data-line-number="2">th2 = zeros(<span class="fl">3</span>,<span class="fl">1</span>); </a>
<a class="sourceLine" id="cb68-3" data-line-number="3">dpest = nan(size(dp));  <span class="co">% 估计得到的压力差</span></a>
<a class="sourceLine" id="cb68-4" data-line-number="4">[th1(<span class="fl">1</span>), th2(<span class="fl">1</span>), dpest(I1)] = staticPumpEst(w, dp, I1);  <span class="co">% 转速区间为1时的Theta1, Theta2估计</span></a>
<a class="sourceLine" id="cb68-5" data-line-number="5">[th1(<span class="fl">2</span>), th2(<span class="fl">2</span>), dpest(I2)] = staticPumpEst(w, dp, I2);  <span class="co">% 转速区间为2时的Theta1, Theta2估计</span></a>
<a class="sourceLine" id="cb68-6" data-line-number="6">[th1(<span class="fl">3</span>), th2(<span class="fl">3</span>), dpest(I3)] = staticPumpEst(w, dp, I3);  <span class="co">% 转速区间为3时的Theta1, Theta2估计</span></a>
<a class="sourceLine" id="cb68-7" data-line-number="7">plot(t, dp, t, dpest) <span class="co">% 比较压差测量值和估计值</span></a>
<a class="sourceLine" id="cb68-8" data-line-number="8">xlabel(<span class="st">&#39;Time (s)&#39;</span>)</a>
<a class="sourceLine" id="cb68-9" data-line-number="9">ylabel(<span class="st">&#39;\Delta P&#39;</span>)</a>
<a class="sourceLine" id="cb68-10" data-line-number="10">legend(<span class="st">&#39;Measured&#39;</span>,<span class="st">&#39;Estimated&#39;</span>,<span class="st">&#39;Location&#39;</span>,<span class="st">&#39;best&#39;</span>)</a>
<a class="sourceLine" id="cb68-11" data-line-number="11">title(<span class="st">&#39;Static Pump Model Validation&#39;</span>)</a></code></pre></div>
<p align=center><img src="..\HIDesign\staticPumpModel.png" style="zoom:120%;" /></p>
</section>
<section>
<h4 id="动态管道模型识别"><strong>动态管道模型识别</strong></h4>
<p>类似于静态泵模型参数估计中的做法，给定方程<span class="math inline">$\hat{Q}(t)=\theta_3+\theta_4\sqrt{\Delta p(t)}+\theta_5\hat Q(t-1)$</span>，通过使用流出率<span class="math inline"><em>Q</em>(<em>t</em>)</span>和压差<span class="math inline"><em>Δ</em><em>p</em>(<em>t</em>)</span>的测量值作为方程的输入输出，可以估计得到参数<span class="math inline"><em>θ</em><sub>3</sub></span>，<span class="math inline"><em>θ</em><sub>4</sub></span>，<span class="math inline"><em>θ</em><sub>5</sub></span>的估计值。此处函数<code>dynamicPipeEst</code>用来执行方程估计过程：</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb69-1" data-line-number="1">function [x3, x4, x5, Qest] = dynamicPipeEst(dp, Q, I)</a>
<a class="sourceLine" id="cb69-2" data-line-number="2"><span class="co">% 该方法用来估计动态管道方程（根据方程用矩阵形式反算参数）在不同泵转速设定下的方程参数</span></a>
<a class="sourceLine" id="cb69-3" data-line-number="3"><span class="co">% I: 转速区间设定的索引</span></a>
<a class="sourceLine" id="cb69-4" data-line-number="4"></a>
<a class="sourceLine" id="cb69-5" data-line-number="5">Q = Q(I);</a>
<a class="sourceLine" id="cb69-6" data-line-number="6">dp = dp(I);</a>
<a class="sourceLine" id="cb69-7" data-line-number="7">R1 = [<span class="fl">0</span>; Q(<span class="fl">1</span>:end-<span class="fl">1</span>)];</a>
<a class="sourceLine" id="cb69-8" data-line-number="8">R2 = dp; R2(R2&lt;<span class="fl">0</span>) = <span class="fl">0</span>; R2 = sqrt(R2);</a>
<a class="sourceLine" id="cb69-9" data-line-number="9">R = [ones(size(R2)), R2, R1];</a>
<a class="sourceLine" id="cb69-10" data-line-number="10"></a>
<a class="sourceLine" id="cb69-11" data-line-number="11"><span class="co">% 移除未运行在定义区间内的样本</span></a>
<a class="sourceLine" id="cb69-12" data-line-number="12">ii = find(I);</a>
<a class="sourceLine" id="cb69-13" data-line-number="13">j = find(diff(ii)~=<span class="fl">1</span>);</a>
<a class="sourceLine" id="cb69-14" data-line-number="14">R = R(<span class="fl">2</span>:end,:); R(j,:) = [];</a>
<a class="sourceLine" id="cb69-15" data-line-number="15">y = Q(<span class="fl">2</span>:end); y(j) = [];</a>
<a class="sourceLine" id="cb69-16" data-line-number="16">x = R\y;</a>
<a class="sourceLine" id="cb69-17" data-line-number="17"></a>
<a class="sourceLine" id="cb69-18" data-line-number="18">x3 = x(<span class="fl">1</span>);</a>
<a class="sourceLine" id="cb69-19" data-line-number="19">x4 = x(<span class="fl">2</span>);</a>
<a class="sourceLine" id="cb69-20" data-line-number="20">x5 = x(<span class="fl">3</span>);</a>
<a class="sourceLine" id="cb69-21" data-line-number="21"></a>
<a class="sourceLine" id="cb69-22" data-line-number="22">Qest = R*x;</a>
<a class="sourceLine" id="cb69-23" data-line-number="23">end</a></code></pre></div>

<div class="sourceCode" id="cb70"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb70-1" data-line-number="1">th3 = zeros(<span class="fl">3</span>,<span class="fl">1</span>);  </a>
<a class="sourceLine" id="cb70-2" data-line-number="2">th4 = zeros(<span class="fl">3</span>,<span class="fl">1</span>); </a>
<a class="sourceLine" id="cb70-3" data-line-number="3">th5 = zeros(<span class="fl">3</span>,<span class="fl">1</span>);</a>
<a class="sourceLine" id="cb70-4" data-line-number="4">[th3(<span class="fl">1</span>), th4(<span class="fl">1</span>), th5(<span class="fl">1</span>)] = dynamicPipeEst(dp, Q, I1); <span class="co">% 转速为区间为1时，估计Theta3, Theta4, Theta5</span></a>
<a class="sourceLine" id="cb70-5" data-line-number="5">[th3(<span class="fl">2</span>), th4(<span class="fl">2</span>), th5(<span class="fl">2</span>)] = dynamicPipeEst(dp, Q, I2); <span class="co">% 转速为区间为2时，估计Theta3, Theta4, Theta5</span></a>
<a class="sourceLine" id="cb70-6" data-line-number="6">[th3(<span class="fl">3</span>), th4(<span class="fl">3</span>), th5(<span class="fl">3</span>)] = dynamicPipeEst(dp, Q, I3); <span class="co">% 转速为区间为3时，估计Theta3, Theta4, Theta5</span></a></code></pre></div>
</section>
<section>
<p>不同于静态泵模型，动态管道模型具有对液体流出率动态依赖的关系。为了模拟该模型在不同转速区间下的表现，从控制系统工具箱中的LPV System模块开发得到一个分段线性模型。该模型被命名为<code>LPV_pump_pipe</code>，函数<code>simulatePumpPipeModel</code>用来运行该模拟过程：</p>
<p align=center><img src="..\HIDesign\CentrifugalPumpFaultDiagnosisUsingResidualAnalysisExample_04.png" style="zoom: 130%;" /></p>

<div class="sourceCode" id="cb71"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb71-1" data-line-number="1">function Qest = simulatePumpPipeModel(Ts,th3,th4,th5)</a>
<a class="sourceLine" id="cb71-2" data-line-number="2"><span class="co">% 动态管道系统的分段线性模型</span></a>
<a class="sourceLine" id="cb71-3" data-line-number="3"><span class="co">% Ts: 采样时间</span></a>
<a class="sourceLine" id="cb71-4" data-line-number="4"><span class="co">% w: 水泵转速</span></a>
<a class="sourceLine" id="cb71-5" data-line-number="5"><span class="co">% th1, th2, th3 对于三种转速区间估计得到的参数，每个参数形状为3*1.</span></a>
<a class="sourceLine" id="cb71-6" data-line-number="6"><span class="co">% 本函数要求安装控制系统工具箱.</span></a>
<a class="sourceLine" id="cb71-7" data-line-number="7"></a>
<a class="sourceLine" id="cb71-8" data-line-number="8">ss1 = ss(th5(<span class="fl">1</span>),th4(<span class="fl">1</span>),th5(<span class="fl">1</span>),th4(<span class="fl">1</span>),Ts);</a>
<a class="sourceLine" id="cb71-9" data-line-number="9">ss2 = ss(th5(<span class="fl">2</span>),th4(<span class="fl">2</span>),th5(<span class="fl">2</span>),th4(<span class="fl">2</span>),Ts);</a>
<a class="sourceLine" id="cb71-10" data-line-number="10">ss3 = ss(th5(<span class="fl">3</span>),th4(<span class="fl">3</span>),th5(<span class="fl">3</span>),th4(<span class="fl">3</span>),Ts);</a>
<a class="sourceLine" id="cb71-11" data-line-number="11">offset = permute([th3(<span class="fl">1</span>),th3(<span class="fl">2</span>),th3(<span class="fl">3</span>)]&#39;,[<span class="fl">3</span> <span class="fl">2</span> <span class="fl">1</span>]);</a>
<a class="sourceLine" id="cb71-12" data-line-number="12">OP = struct(<span class="st">&#39;Region&#39;</span>,[<span class="fl">1</span> <span class="fl">2</span> <span class="fl">3</span>]&#39;);</a>
<a class="sourceLine" id="cb71-13" data-line-number="13">sys = cat(<span class="fl">3</span>,ss1,ss2,ss3);</a>
<a class="sourceLine" id="cb71-14" data-line-number="14">sys.SamplingGrid = OP;</a>
<a class="sourceLine" id="cb71-15" data-line-number="15"></a>
<a class="sourceLine" id="cb71-16" data-line-number="16">assignin(<span class="st">&#39;base&#39;</span>,<span class="st">&#39;sys&#39;</span>,sys)</a>
<a class="sourceLine" id="cb71-17" data-line-number="17">assignin(<span class="st">&#39;base&#39;</span>,<span class="st">&#39;offset&#39;</span>,offset)</a>
<a class="sourceLine" id="cb71-18" data-line-number="18">mdl = <span class="st">&#39;LPV_pump_pipe&#39;</span>;</a>
<a class="sourceLine" id="cb71-19" data-line-number="19">sim(mdl);</a>
<a class="sourceLine" id="cb71-20" data-line-number="20">Qest = logsout.get(<span class="st">&#39;Qest&#39;</span>);</a>
<a class="sourceLine" id="cb71-21" data-line-number="21">Qest = Qest.Values;</a>
<a class="sourceLine" id="cb71-22" data-line-number="22">Qest = Qest.Data;</a>
<a class="sourceLine" id="cb71-23" data-line-number="23">end</a></code></pre></div>
</section>
<section>
<div class="sourceCode" id="cb72"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="co">% 检查控制系统工具箱是否可用</span></a>
<a class="sourceLine" id="cb72-2" data-line-number="2">ControlsToolboxAvailable = ~isempty(ver(<span class="st">&#39;control&#39;</span>)) &amp;&amp; license(<span class="st">&#39;test&#39;</span>, <span class="st">&#39;Control_Toolbox&#39;</span>);</a>
<a class="sourceLine" id="cb72-3" data-line-number="3">if ControlsToolboxAvailable</a>
<a class="sourceLine" id="cb72-4" data-line-number="4">    <span class="co">% 模拟动态管道模型，使用压力测量值作为输入</span></a>
<a class="sourceLine" id="cb72-5" data-line-number="5">    Ts = t(<span class="fl">2</span>)-t(<span class="fl">1</span>);</a>
<a class="sourceLine" id="cb72-6" data-line-number="6">    Switch = ones(size(w));</a>
<a class="sourceLine" id="cb72-7" data-line-number="7">    Switch(I2) = <span class="fl">2</span>;</a>
<a class="sourceLine" id="cb72-8" data-line-number="8">    Switch(I3) = <span class="fl">3</span>;</a>
<a class="sourceLine" id="cb72-9" data-line-number="9">    UseEstimatedP = <span class="fl">0</span>;</a>
<a class="sourceLine" id="cb72-10" data-line-number="10">    Qest_pipe = simulatePumpPipeModel(Ts,th3,th4,th5);</a>
<a class="sourceLine" id="cb72-11" data-line-number="11">    plot(t,Q,t,Qest_pipe) <span class="co">% 画出估计得到和测量得到液体流出率值</span></a>
<a class="sourceLine" id="cb72-12" data-line-number="12">else</a>
<a class="sourceLine" id="cb72-13" data-line-number="13">    <span class="co">% 加载从分段线性simulink模型中预存的模拟结果</span></a>
<a class="sourceLine" id="cb72-14" data-line-number="14">    load DynamicOperationData Qest_pipe</a>
<a class="sourceLine" id="cb72-15" data-line-number="15">    Ts = t(<span class="fl">2</span>)-t(<span class="fl">1</span>);</a>
<a class="sourceLine" id="cb72-16" data-line-number="16">    plot(t,Q,t,Qest_pipe)</a>
<a class="sourceLine" id="cb72-17" data-line-number="17">end</a>
<a class="sourceLine" id="cb72-18" data-line-number="18">xlabel(<span class="st">&#39;Time (s)&#39;</span>)</a>
<a class="sourceLine" id="cb72-19" data-line-number="19">ylabel(<span class="st">&#39;Flow rate (Q), m^3/s&#39;</span>)</a>
<a class="sourceLine" id="cb72-20" data-line-number="20">legend(<span class="st">&#39;Measured&#39;</span>,<span class="st">&#39;Estimated&#39;</span>,<span class="st">&#39;Location&#39;</span>,<span class="st">&#39;best&#39;</span>)</a>
<a class="sourceLine" id="cb72-21" data-line-number="21">title(<span class="st">&#39;Dynamic Pipe Model Validation&#39;</span>)</a></code></pre></div>
<p align=center><img src="..\HIDesign\dynamicPumpModel.png" style="zoom:120%;" /></p>
</section>
<section>
<h4 id="动态泵-管道模型识别"><strong>动态泵-管道模型识别</strong></h4>
<p>动态泵-管道模型使用同以上部分相同的参数（<span class="math inline"><em>θ</em><sub>3</sub></span>,<span class="math inline"><em>θ</em><sub>4</sub></span>,<span class="math inline"><em>θ</em><sub>5</sub></span>），不同的是模型模拟使用静态泵模型中估计得到的压差，而不是测量得到的压差，其他步骤如同动态管道模型识别过程中的操作</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb73-1" data-line-number="1">if ControlsToolboxAvailable</a>
<a class="sourceLine" id="cb73-2" data-line-number="2">    UseEstimatedP = <span class="fl">1</span>;</a>
<a class="sourceLine" id="cb73-3" data-line-number="3">    Qest_pump_pipe = simulatePumpPipeModel(Ts,th3,th4,th5);</a>
<a class="sourceLine" id="cb73-4" data-line-number="4">    plot(t,Q,t,Qest_pump_pipe) <span class="co">% 比较测量和预测得到的液体流出率</span></a>
<a class="sourceLine" id="cb73-5" data-line-number="5">else</a>
<a class="sourceLine" id="cb73-6" data-line-number="6">    load DynamicOperationData Qest_pump_pipe </a>
<a class="sourceLine" id="cb73-7" data-line-number="7">    plot(t,Q,t,Qest_pump_pipe)</a>
<a class="sourceLine" id="cb73-8" data-line-number="8">end</a>
<a class="sourceLine" id="cb73-9" data-line-number="9"></a>
<a class="sourceLine" id="cb73-10" data-line-number="10">xlabel(<span class="st">&#39;Time (s)&#39;</span>)</a>
<a class="sourceLine" id="cb73-11" data-line-number="11">ylabel(<span class="st">&#39;Flow rate Q (m^3/s)&#39;</span>)</a>
<a class="sourceLine" id="cb73-12" data-line-number="12">legend(<span class="st">&#39;Measured&#39;</span>,<span class="st">&#39;Estimated&#39;</span>,<span class="st">&#39;location&#39;</span>,<span class="st">&#39;best&#39;</span>)</a>
<a class="sourceLine" id="cb73-13" data-line-number="13">title(<span class="st">&#39;Dynamic Pump-Pipe Model Validation&#39;</span>)</a></code></pre></div>
</section>
<section>
<p align=center><img src="..\HIDesign\dynamicPumpPipeModel.png" style="zoom:130%;" /></p>
<p>该结果与使用压差测量值得到的结果几乎一致（比较上图与上上图）</p>
</section>
<section>
<h4 id="动态逆泵模型识别"><strong>动态逆泵模型识别</strong></h4>
<p>参数<span class="math inline"><em>θ</em><sub>6</sub></span>,…,<span class="math inline"><em>θ</em><sub>10</sub></span>的估计符合同样的准则，回归分析测量得到的扭矩值，前一时刻的扭矩值以及速度值得到参数。然而，此时分速度区间分段线性模型并不能很好的拟合数据，因此使用了一种不同的黑盒方法。该方法使用有理回归器识别得到一个经数据拟合后的非线性的自回归各态历经模型<code>identifyNonlinearARXModel</code>，过程如下：</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb74-1" data-line-number="1">function syse = identifyNonlinearARXModel(Mmot,w,Q,Ts,N)</a>
<a class="sourceLine" id="cb74-2" data-line-number="2"><span class="co">%identifyNonlinearARXModel 识别非线性的自回归各态历经模型对于双输入(w, Q), 单输出(Mmot)数据</span></a>
<a class="sourceLine" id="cb74-3" data-line-number="3"><span class="co">% 输入：</span></a>
<a class="sourceLine" id="cb74-4" data-line-number="4"><span class="co">%  w: 转速</span></a>
<a class="sourceLine" id="cb74-5" data-line-number="5"><span class="co">%  Q: 液体流出率</span></a>
<a class="sourceLine" id="cb74-6" data-line-number="6"><span class="co">%  Mmot: 电机转矩</span></a>
<a class="sourceLine" id="cb74-7" data-line-number="7"><span class="co">%  N: 使用样本的个数</span></a>
<a class="sourceLine" id="cb74-8" data-line-number="8"><span class="co">% 输出：</span></a>
<a class="sourceLine" id="cb74-9" data-line-number="9"><span class="co">%  syse: 识别到的模型</span></a>
<a class="sourceLine" id="cb74-10" data-line-number="10"><span class="co">%</span></a>
<a class="sourceLine" id="cb74-11" data-line-number="11"><span class="co">% 本函数使用来自系统识别工具箱中的NLARX估计器</span></a>
<a class="sourceLine" id="cb74-12" data-line-number="12"></a>
<a class="sourceLine" id="cb74-13" data-line-number="13">sys = idnlarx([<span class="fl">2</span> <span class="fl">2</span> <span class="fl">1</span> <span class="fl">0</span> <span class="fl">1</span>],<span class="st">&#39;&#39;</span>,<span class="st">&#39;CustomRegressors&#39;</span>,{<span class="st">&#39;u1(t-2)^2&#39;</span>,<span class="st">&#39;u1(t)*u2(t-2)&#39;</span>,<span class="st">&#39;u2(t)^2&#39;</span>});</a>
<a class="sourceLine" id="cb74-14" data-line-number="14">data = iddata(Mmot,[w Q],Ts);</a>
<a class="sourceLine" id="cb74-15" data-line-number="15">opt = nlarxOptions;</a>
<a class="sourceLine" id="cb74-16" data-line-number="16">opt.Focus = <span class="st">&#39;simulation&#39;</span>;</a>
<a class="sourceLine" id="cb74-17" data-line-number="17">opt.SearchOptions.MaxIterations = <span class="fl">500</span>;</a>
<a class="sourceLine" id="cb74-18" data-line-number="18">syse = nlarx(data(<span class="fl">1</span>:N),sys,opt);</a>
<a class="sourceLine" id="cb74-19" data-line-number="19">end</a></code></pre></div>
<div class="sourceCode" id="cb75"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb75-1" data-line-number="1"><span class="co">% 使用550个样本中的300个识别模型</span></a>
<a class="sourceLine" id="cb75-2" data-line-number="2">N = <span class="fl">350</span>;</a>
<a class="sourceLine" id="cb75-3" data-line-number="3">sys3 = identifyNonlinearARXModel(Mmot,w,Q,Ts,N)</a></code></pre></div>
</section>
<section>
<p>得到的非线性的自回归各态历经模型如下：</p>
<p align=center><img src="..\HIDesign\ARXmodel.PNG" style="zoom: 120%;" /></p>
</section>
<section>
<p>使用该模型模拟估计得到的电机扭矩值和测量得到的电机扭矩值绘图如下：</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb76-1" data-line-number="1">Mmot_est = sim(sys3,[w Q]);</a>
<a class="sourceLine" id="cb76-2" data-line-number="2">plot(t,Mmot,t,Mmot_est) <span class="co">% 比较测量和估计得到的电机扭矩值</span></a>
<a class="sourceLine" id="cb76-3" data-line-number="3">xlabel(<span class="st">&#39;Time (s)&#39;</span>)</a>
<a class="sourceLine" id="cb76-4" data-line-number="4">ylabel(<span class="st">&#39;Motor Torque (Nm)&#39;</span>)</a>
<a class="sourceLine" id="cb76-5" data-line-number="5">legend(<span class="st">&#39;Measured&#39;</span>,<span class="st">&#39;Estimated&#39;</span>,<span class="st">&#39;location&#39;</span>,<span class="st">&#39;best&#39;</span>)</a>
<a class="sourceLine" id="cb76-6" data-line-number="6">title(<span class="st">&#39;Inverse pump model validation&#39;</span>)</a></code></pre></div>
<p align=center><img src="..\HIDesign\inversePumpModel.png" style="zoom:140%;" /></p>
</section>
</section>
<section align=left>
<h4 id="第三步残差生成"><strong>第三步：残差生成</strong></h4>
<section>
<p>由上述四种方法得到了四个模型的估计值，它们与对应测量值的差便可作为残差用作后续分析的输入</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb77-1" data-line-number="1">r1 = dp - dpest;  <span class="co">%残差1：压差残差</span></a>
<a class="sourceLine" id="cb77-2" data-line-number="2">r2 = Q - Qest_pipe;  <span class="co">%残差2：管道模型流出率残差</span></a>
<a class="sourceLine" id="cb77-3" data-line-number="3">r3 = Q - Qest_pump_pipe;  <span class="co">%残差3：泵-管道模型流出率残差</span></a>
<a class="sourceLine" id="cb77-4" data-line-number="4">r4 = Mmot - movmean(Mmot_est,[<span class="fl">1</span> <span class="fl">5</span>]);  <span class="co">%残差4：电机扭矩残差，此处使用移动平均平滑化方法处理数据，因为原始残差数据方差太大</span></a></code></pre></div>
</section>
<section>
<p>可视化得到的残差：</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb78-1" data-line-number="1">figure</a>
<a class="sourceLine" id="cb78-2" data-line-number="2">subplot(<span class="fl">221</span>)</a>
<a class="sourceLine" id="cb78-3" data-line-number="3">plot(t,r1)</a>
<a class="sourceLine" id="cb78-4" data-line-number="4">ylabel(<span class="st">&#39;Static pump - r1&#39;</span>)</a>
<a class="sourceLine" id="cb78-5" data-line-number="5">subplot(<span class="fl">222</span>)</a>
<a class="sourceLine" id="cb78-6" data-line-number="6">plot(t,r2)</a>
<a class="sourceLine" id="cb78-7" data-line-number="7">ylabel(<span class="st">&#39;Dynamic pipe - r2&#39;</span>)</a>
<a class="sourceLine" id="cb78-8" data-line-number="8">subplot(<span class="fl">223</span>)</a>
<a class="sourceLine" id="cb78-9" data-line-number="9">plot(t,r3)</a>
<a class="sourceLine" id="cb78-10" data-line-number="10">ylabel(<span class="st">&#39;Dynamic pump-pipe - r3&#39;</span>)</a>
<a class="sourceLine" id="cb78-11" data-line-number="11">xlabel(<span class="st">&#39;Time (s)&#39;</span>)</a>
<a class="sourceLine" id="cb78-12" data-line-number="12">subplot(<span class="fl">224</span>)</a>
<a class="sourceLine" id="cb78-13" data-line-number="13">plot(t,r4)</a>
<a class="sourceLine" id="cb78-14" data-line-number="14">ylabel(<span class="st">&#39;Dynamic inverse pump - r4&#39;</span>)</a>
<a class="sourceLine" id="cb78-15" data-line-number="15">xlabel(<span class="st">&#39;Time (s)&#39;</span>)</a></code></pre></div>
<p align=center><img src="..\HIDesign\residualPlot.png" style="zoom:110%;" /></p>
</section>
</section>
<section align=left>
<h4 id="第四步残差特征提取"><strong>第四步：残差特征提取</strong></h4>
<section>
<p>从第三步中得到的残差，可以用来做特征提取（如常规的信号处理方法，最大峰值、信号方差等），得到的特征被用于故障类型分离</p>
<p>考虑对使用伪随机位序列作为输入，实现的一组50次实验的数据采集。每组实验分别按照以下10种模式进行：</p>
<ol type="1">
<li>健康水泵</li>
<li>故障1：间隙距磨损</li>
<li>故障2：叶轮出口小沉积</li>
<li>故障3：叶轮进口沉积</li>
<li>故障4：叶轮出口物理磨损</li>
<li>故障5：叶片折断</li>
<li>故障6：气穴现象</li>
<li>故障7：转速传感器偏差</li>
<li>故障8：流量计偏差</li>
<li>故障9：压力传感器偏差</li>
</ol>
</section>
<section>
<p>下面加载实验数据（<span class="math inline">50 × 1</span> <code>cell</code>型数据）：</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb79-1" data-line-number="1">load MultiSpeedOperationData</a>
<a class="sourceLine" id="cb79-2" data-line-number="2"><span class="co">% 生成实验工况标签</span></a>
<a class="sourceLine" id="cb79-3" data-line-number="3">Labels = {<span class="st">&#39;Healthy&#39;</span>,<span class="st">&#39;ClearanceGapWear&#39;</span>,<span class="st">&#39;ImpellerOutletDeposit&#39;</span>,...</a>
<a class="sourceLine" id="cb79-4" data-line-number="4">   <span class="st">&#39;ImpellerInletDeposit&#39;</span>,<span class="st">&#39;AbrasiveWear&#39;</span>,<span class="st">&#39;BrokenBlade&#39;</span>,<span class="st">&#39;Cavitation&#39;</span>,<span class="st">&#39;SpeedSensorBias&#39;</span>,...</a>
<a class="sourceLine" id="cb79-5" data-line-number="5">    <span class="st">&#39;FlowmeterBias&#39;</span>,<span class="st">&#39;PressureSensorBias&#39;</span>};</a></code></pre></div>
<p>接下来生成针对每种实验工况下每组数据得到的残差值，可使用以下<code>helperComputeEnsembleResidues</code>函数</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb80-1" data-line-number="1">function R = helperComputeEnsembleResidues(Ensemble,Ts,sys,x1,x2,x3,x4,x5)</a>
<a class="sourceLine" id="cb80-2" data-line-number="2"><span class="co">%helperComputeEnsembleResidues Compute residues for a given dataset ensemble.</span></a>
<a class="sourceLine" id="cb80-3" data-line-number="3"><span class="co">% This function is only in support of</span></a>
<a class="sourceLine" id="cb80-4" data-line-number="4"><span class="co">% CentrifugalPumpFaultDiagnosisUsingResidualAnalysisExample. It may change</span></a>
<a class="sourceLine" id="cb80-5" data-line-number="5"><span class="co">% in a future release.</span></a>
<a class="sourceLine" id="cb80-6" data-line-number="6"></a>
<a class="sourceLine" id="cb80-7" data-line-number="7"><span class="co">%  Copyright 2017 The MathWorks, Inc.</span></a>
<a class="sourceLine" id="cb80-8" data-line-number="8"></a>
<a class="sourceLine" id="cb80-9" data-line-number="9">load_system(<span class="st">&#39;LPV_pump_pipe&#39;</span>)</a>
<a class="sourceLine" id="cb80-10" data-line-number="10">N = numel(Ensemble);</a>
<a class="sourceLine" id="cb80-11" data-line-number="11">r1 = cell(N,<span class="fl">1</span>);</a>
<a class="sourceLine" id="cb80-12" data-line-number="12">r2 = r1;</a>
<a class="sourceLine" id="cb80-13" data-line-number="13">r3 = r1;</a>
<a class="sourceLine" id="cb80-14" data-line-number="14">r4 = r1;</a>
<a class="sourceLine" id="cb80-15" data-line-number="15">for kexp = <span class="fl">1</span>:N</a>
<a class="sourceLine" id="cb80-16" data-line-number="16">   [r1{kexp},r2{kexp},r3{kexp},r4{kexp}] = ...</a>
<a class="sourceLine" id="cb80-17" data-line-number="17">      localComputeResidue(Ensemble{kexp},Ts,sys,x1,x2,x3,x4,x5);</a>
<a class="sourceLine" id="cb80-18" data-line-number="18">end</a>
<a class="sourceLine" id="cb80-19" data-line-number="19">R = [r1,r2,r3,r4];</a>
<a class="sourceLine" id="cb80-20" data-line-number="20"></a>
<a class="sourceLine" id="cb80-21" data-line-number="21"><span class="co">%--------------------------------------------------------------------------</span></a>
<a class="sourceLine" id="cb80-22" data-line-number="22">function [r1,r2,r3,r4] = localComputeResidue(Data,Ts,sys,x1,x2,x3,x4,x5)</a>
<a class="sourceLine" id="cb80-23" data-line-number="23"><span class="co">% Residues for one dataset.</span></a>
<a class="sourceLine" id="cb80-24" data-line-number="24">w = Data.Speed;</a>
<a class="sourceLine" id="cb80-25" data-line-number="25">I1 = w&lt;=<span class="fl">900</span>;</a>
<a class="sourceLine" id="cb80-26" data-line-number="26">I2 = w&gt;<span class="fl">900</span> &amp; w&lt;=<span class="fl">1500</span>;</a>
<a class="sourceLine" id="cb80-27" data-line-number="27">I3 = w&gt;<span class="fl">1500</span>;</a>
<a class="sourceLine" id="cb80-28" data-line-number="28">rho = <span class="fl">1800</span>;</a>
<a class="sourceLine" id="cb80-29" data-line-number="29">g = <span class="fl">9.81</span>;</a>
<a class="sourceLine" id="cb80-30" data-line-number="30">dp = Data.Head*rho*g;</a>
<a class="sourceLine" id="cb80-31" data-line-number="31">Q = Data.Discharge;</a>
<a class="sourceLine" id="cb80-32" data-line-number="32">Mmot = Data.MotorTorque;</a>
<a class="sourceLine" id="cb80-33" data-line-number="33"></a>
<a class="sourceLine" id="cb80-34" data-line-number="34">dpest = NaN(size(dp));</a>
<a class="sourceLine" id="cb80-35" data-line-number="35">dpest(I1) = [w(I1).^<span class="fl">2</span> w(I1)]*[x1(<span class="fl">1</span>); x2(<span class="fl">1</span>)];</a>
<a class="sourceLine" id="cb80-36" data-line-number="36">dpest(I2) = [w(I2).^<span class="fl">2</span> w(I2)]*[x1(<span class="fl">2</span>); x2(<span class="fl">2</span>)];</a>
<a class="sourceLine" id="cb80-37" data-line-number="37">dpest(I3) = [w(I3).^<span class="fl">2</span> w(I3)]*[x1(<span class="fl">3</span>); x2(<span class="fl">3</span>)];</a>
<a class="sourceLine" id="cb80-38" data-line-number="38">r1 = dp - dpest;</a>
<a class="sourceLine" id="cb80-39" data-line-number="39"></a>
<a class="sourceLine" id="cb80-40" data-line-number="40">Switch = ones(size(w));</a>
<a class="sourceLine" id="cb80-41" data-line-number="41">Switch(I2) = <span class="fl">2</span>;</a>
<a class="sourceLine" id="cb80-42" data-line-number="42">Switch(I3) = <span class="fl">3</span>;</a>
<a class="sourceLine" id="cb80-43" data-line-number="43">assignin(<span class="st">&#39;base&#39;</span>, <span class="st">&#39;Switch&#39;</span>, Switch);</a>
<a class="sourceLine" id="cb80-44" data-line-number="44">assignin(<span class="st">&#39;base&#39;</span>, <span class="st">&#39;UseEstimatedP&#39;</span>, <span class="fl">0</span>);</a>
<a class="sourceLine" id="cb80-45" data-line-number="45">Qest_pipe = simulatePumpPipeModel(Ts,x3,x4,x5);</a>
<a class="sourceLine" id="cb80-46" data-line-number="46">r2 = Q - Qest_pipe;</a>
<a class="sourceLine" id="cb80-47" data-line-number="47"></a>
<a class="sourceLine" id="cb80-48" data-line-number="48">assignin(<span class="st">&#39;base&#39;</span>, <span class="st">&#39;UseEstimatedP&#39;</span>, <span class="fl">1</span>);</a>
<a class="sourceLine" id="cb80-49" data-line-number="49">Qest_pump_pipe = simulatePumpPipeModel(Ts,x3,x4,x5);</a>
<a class="sourceLine" id="cb80-50" data-line-number="50">r3 = Q - Qest_pump_pipe;</a>
<a class="sourceLine" id="cb80-51" data-line-number="51"></a>
<a class="sourceLine" id="cb80-52" data-line-number="52">zv = iddata(Mmot,[w Q/<span class="fl">3600</span>],Ts);</a>
<a class="sourceLine" id="cb80-53" data-line-number="53">e = pe(sys,zv); </a>
<a class="sourceLine" id="cb80-54" data-line-number="54">r4 = e.y;</a></code></pre></div>
<p>基于此函数的基础上，可以出10组实验得到的残差值，如健康水泵模型的残差计算如下所示：</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb81-1" data-line-number="1">HealthyR = helperComputeEnsembleResidues(HealthyEnsemble,Ts,sys3,th1,th2,th3,th4,th5); <span class="co">% 健康数据残差</span></a></code></pre></div>
</section>
<section>
<p>因针对所有数据的计算较为耗时，这里直接导入计算后的结果，如下：</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb82-1" data-line-number="1"><span class="co">% 导入从helperComputeEnsembleResidues函数中计算得到的结果</span></a>
<a class="sourceLine" id="cb82-2" data-line-number="2">load Residuals</a></code></pre></div>
<p>每组实验得到数据形式为<span class="math inline">50 × 4</span> <code>cell</code>型的残差数据，4表示共有4种残差值，对于每个<code>cell</code>中的元素，它们是形式为<span class="math inline">550 × 1</span>时序数据</p>
</section>
<section>
<p>得到残差后，能有效区分故障类型的特征无法直观得到，因此使用函数<code>helperGenerateFeatureTable</code>生成多种常用的备选特征，诸如均值、最大峰值、方差、谷值、1-范数等，当然在此之前所有残差数据都应使用<code>MinMaxScaler</code>归一化到健康模式数据的范围内</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb83-1" data-line-number="1">function [T, MinMax] = helperGenerateFeatureTable(Ensemble, CandidateFeatures, Names, MinMax)</a>
<a class="sourceLine" id="cb83-2" data-line-number="2"><span class="co">%helperGenerateFeatureTable Extract features from residues.</span></a>
<a class="sourceLine" id="cb83-3" data-line-number="3"><span class="co">% This function is only in support of</span></a>
<a class="sourceLine" id="cb83-4" data-line-number="4"><span class="co">% CentrifugalPumpFaultDiagnosisUsingResidualAnalysisExample. It may change</span></a>
<a class="sourceLine" id="cb83-5" data-line-number="5"><span class="co">% in a future release.</span></a>
<a class="sourceLine" id="cb83-6" data-line-number="6"></a>
<a class="sourceLine" id="cb83-7" data-line-number="7"><span class="co">%  Copyright 2018 The MathWorks, Inc.</span></a>
<a class="sourceLine" id="cb83-8" data-line-number="8"></a>
<a class="sourceLine" id="cb83-9" data-line-number="9">[N,m] = size(Ensemble); <span class="co">% 第N次实验，第m个残差</span></a>
<a class="sourceLine" id="cb83-10" data-line-number="10">nf = length(Names); <span class="co">% nf个特征</span></a>
<a class="sourceLine" id="cb83-11" data-line-number="11">F = zeros(N,m*nf);</a>
<a class="sourceLine" id="cb83-12" data-line-number="12">ColNames = cell(<span class="fl">1</span>,m*nf);</a>
<a class="sourceLine" id="cb83-13" data-line-number="13">for j = <span class="fl">1</span>:nf</a>
<a class="sourceLine" id="cb83-14" data-line-number="14">   fcn = CandidateFeatures{j};</a>
<a class="sourceLine" id="cb83-15" data-line-number="15">   F(:,(j-<span class="fl">1</span>)*m+(<span class="fl">1</span>:m)) = cellfun(@(x)fcn(x),Ensemble,<span class="st">&#39;uni&#39;</span>,<span class="fl">1</span>);</a>
<a class="sourceLine" id="cb83-16" data-line-number="16">   ColNames((j-<span class="fl">1</span>)*m+(<span class="fl">1</span>:m)) = strseq(Names{j},<span class="fl">1</span>:m);</a>
<a class="sourceLine" id="cb83-17" data-line-number="17">end</a>
<a class="sourceLine" id="cb83-18" data-line-number="18">if nargout&gt;<span class="fl">1</span> &amp;&amp; nargin&lt;<span class="fl">4</span></a>
<a class="sourceLine" id="cb83-19" data-line-number="19">   MinMax = [min(F); max(F)];</a>
<a class="sourceLine" id="cb83-20" data-line-number="20">end</a>
<a class="sourceLine" id="cb83-21" data-line-number="21"></a>
<a class="sourceLine" id="cb83-22" data-line-number="22">if nargin&gt;<span class="fl">3</span> || nargout&gt;<span class="fl">1</span></a>
<a class="sourceLine" id="cb83-23" data-line-number="23">   Range = diff(MinMax);</a>
<a class="sourceLine" id="cb83-24" data-line-number="24">   F = (F-MinMax(<span class="fl">1</span>,:))./Range;</a>
<a class="sourceLine" id="cb83-25" data-line-number="25">end</a>
<a class="sourceLine" id="cb83-26" data-line-number="26">T = array2table(F,<span class="st">&#39;VariableNames&#39;</span>,ColNames);</a></code></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb84-1" data-line-number="1">CandidateFeatures = {@mean, @(x)max(abs(x)), @kurtosis, @var, @(x)sum(abs(x))};</a>
<a class="sourceLine" id="cb84-2" data-line-number="2">FeatureNames = {<span class="st">&#39;Mean&#39;</span>,<span class="st">&#39;Max&#39;</span>,<span class="st">&#39;Kurtosis&#39;</span>,<span class="st">&#39;Variance&#39;</span>,<span class="st">&#39;OneNorm&#39;</span>};</a>
<a class="sourceLine" id="cb84-3" data-line-number="3"><span class="co">% 对于每种故障模式生成特征表</span></a>
<a class="sourceLine" id="cb84-4" data-line-number="4">[HealthyFeature, MinMax] = helperGenerateFeatureTable(HealthyR, CandidateFeatures, FeatureNames);</a>
<a class="sourceLine" id="cb84-5" data-line-number="5">Fault1Feature  = helperGenerateFeatureTable(Fault1R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-6" data-line-number="6">Fault2Feature  = helperGenerateFeatureTable(Fault2R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-7" data-line-number="7">Fault3Feature  = helperGenerateFeatureTable(Fault3R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-8" data-line-number="8">Fault4Feature  = helperGenerateFeatureTable(Fault4R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-9" data-line-number="9">Fault5Feature  = helperGenerateFeatureTable(Fault5R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-10" data-line-number="10">Fault6Feature  = helperGenerateFeatureTable(Fault6R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-11" data-line-number="11">Fault7Feature  = helperGenerateFeatureTable(Fault7R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-12" data-line-number="12">Fault8Feature  = helperGenerateFeatureTable(Fault8R,  CandidateFeatures, FeatureNames, MinMax);</a>
<a class="sourceLine" id="cb84-13" data-line-number="13">Fault9Feature  = helperGenerateFeatureTable(Fault9R,  CandidateFeatures, FeatureNames, MinMax);</a></code></pre></div>
</section>
<section>
<p>每个残差特征表形式为<span class="math inline">50 × 20</span> <code>table</code>数据，20表示所有4种残差得到的特征（每种残差提取5种特征），50表示50次实验</p>
<p>下一步，将所有特征数据打上标签并拼接到一起，操作如下：</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb85-1" data-line-number="1">N = <span class="fl">50</span>; <span class="co">% 每种实验的实验次数</span></a>
<a class="sourceLine" id="cb85-2" data-line-number="2">FeatureTable = [...</a>
<a class="sourceLine" id="cb85-3" data-line-number="3">   [HealthyFeature(<span class="fl">1</span>:N,:), repmat(Labels(<span class="fl">1</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-4" data-line-number="4">   [Fault1Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">2</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-5" data-line-number="5">   [Fault2Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">3</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-6" data-line-number="6">   [Fault3Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">4</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-7" data-line-number="7">   [Fault4Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">5</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-8" data-line-number="8">   [Fault5Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">6</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-9" data-line-number="9">   [Fault6Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">7</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-10" data-line-number="10">   [Fault7Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">8</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-11" data-line-number="11">   [Fault8Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">9</span>),[N,<span class="fl">1</span>])];...</a>
<a class="sourceLine" id="cb85-12" data-line-number="12">   [Fault9Feature(<span class="fl">1</span>:N,:),  repmat(Labels(<span class="fl">10</span>),[N,<span class="fl">1</span>])]];</a>
<a class="sourceLine" id="cb85-13" data-line-number="13">FeatureTable.Properties.VariableNames{end} = <span class="st">&#39;Condition&#39;</span>;</a>
<a class="sourceLine" id="cb85-14" data-line-number="14"></a>
<a class="sourceLine" id="cb85-15" data-line-number="15"><span class="co">% 随机查看训练样本数据</span></a>
<a class="sourceLine" id="cb85-16" data-line-number="16">disp(FeatureTable([<span class="fl">2</span> <span class="fl">13</span> <span class="fl">37</span> <span class="fl">49</span> <span class="fl">61</span> <span class="fl">62</span> <span class="fl">73</span> <span class="fl">85</span> <span class="fl">102</span> <span class="fl">120</span>],:))</a></code></pre></div>
<p align=center><img src="..\HIDesign\residueFeatures.PNG" style="zoom:140%;" /></p>
</section>
</section>
<section align=left>
<h4 id="第五步分类器设计"><strong>第五步：分类器设计</strong></h4>
<section>
<h4 id="使用散点绘图可视化模式分离"><strong>使用散点绘图可视化模式分离</strong></h4>
<p>有了残差特征训练数据后，可以通过散点绘图目视的方法观察哪些特征适合用来分离故障。例如对于故障1：间隙距磨损，可以生成一幅标记上“Healthy”和“ClearanceGapWear”标签的特征散点图：</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb86-1" data-line-number="1">T = FeatureTable(:,<span class="fl">1</span>:<span class="fl">20</span>);</a>
<a class="sourceLine" id="cb86-2" data-line-number="2">P = T.Variables;</a>
<a class="sourceLine" id="cb86-3" data-line-number="3">R = FeatureTable.Condition;</a>
<a class="sourceLine" id="cb86-4" data-line-number="4">I = strcmp(R,<span class="st">&#39;Healthy&#39;</span>) | strcmp(R,<span class="st">&#39;ClearanceGapWear&#39;</span>);</a>
<a class="sourceLine" id="cb86-5" data-line-number="5">f = figure;</a>
<a class="sourceLine" id="cb86-6" data-line-number="6">gplotmatrix(P(I,:),[],R(I))</a>
<a class="sourceLine" id="cb86-7" data-line-number="7">f.Position(<span class="fl">3</span>:<span class="fl">4</span>) = f.Position(<span class="fl">3</span>:<span class="fl">4</span>)*<span class="fl">1.5</span>;</a></code></pre></div>
</section>
<section>
<p align=center><img data-src="..\HIDesign\featuresPlot.png" style="zoom:140%;"/></p>
<p>依稀可以看出，第1列和第17列的特征可以有效地分离健康和故障1工况</p>
</section>
<section>
<p>接下来仔细分析这两个特征：</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb87-1" data-line-number="1">f = figure;</a>
<a class="sourceLine" id="cb87-2" data-line-number="2">Names = FeatureTable.Properties.VariableNames;</a>
<a class="sourceLine" id="cb87-3" data-line-number="3">J = [<span class="fl">1</span> <span class="fl">17</span>];  <span class="co">%查看第1列和第17列特征的名称</span></a>
<a class="sourceLine" id="cb87-4" data-line-number="4">fprintf(<span class="st">&#39;Selected features for clearance gap fault: %s\n&#39;</span>,strjoin(Names(J),<span class="st">&#39;, &#39;</span>))</a></code></pre></div>
<p>继续查看这两个特征构成的散点图：</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb88-1" data-line-number="1">gplotmatrix(P(I,[<span class="fl">1</span> <span class="fl">17</span>]),[],R(I))</a></code></pre></div>
<p align=center><img src="..\HIDesign\selectedFeaturePlot.png" style="zoom:80%;" /></p>
<p>绘图显示，特征1：“Mean1”和特征17：“OneNorm1”可以被用来区分健康和间隙距故障工况，同样的分析方法可以应用于其他故障模式分析。对于所有的故障模式，都可以找到一组所有特征的子集特征来区分这些故障模式。然而，由于统一特征可能会被多种故障模式影响，所以故障分离会更加困难。例如特征1和特征17就并不是对所有故障类型都能区分，相反对于传感器偏差类故障来说，故障分离就简单一些，因为针对它们的诊断，有很多的有效特征可选</p>
</section>
<section>
<p>对于定义的三种传感器偏差类故障，可以从散点图的手动查看中选出合适的特征</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb89-1" data-line-number="1">figure;</a>
<a class="sourceLine" id="cb89-2" data-line-number="2">I = strcmp(R,<span class="st">&#39;Healthy&#39;</span>) | strcmp(R,<span class="st">&#39;PressureSensorBias&#39;</span>) | strcmp(R,<span class="st">&#39;SpeedSensorBias&#39;</span>) | strcmp(R,<span class="st">&#39;FlowmeterBias&#39;</span>);</a>
<a class="sourceLine" id="cb89-3" data-line-number="3">J = [<span class="fl">1</span> <span class="fl">4</span> <span class="fl">6</span> <span class="fl">16</span> <span class="fl">20</span>]; <span class="co">% 选择特征的索引，分别对应Mean1, Mean4, Max2, Variance4, OneNorm4五种特征</span></a>
<a class="sourceLine" id="cb89-4" data-line-number="4">fprintf(<span class="st">&#39;Selected features for sensors&#39;&#39; bias: %s\n&#39;</span>,strjoin(Names(J),<span class="st">&#39;, &#39;</span>))</a></code></pre></div>
<p>画出这五种特征在三种传感器偏差故障和健康时的散点图：</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb90-1" data-line-number="1">gplotmatrix(P(I,J),[],R(I))</a></code></pre></div>
<p align=center><img src="..\HIDesign\selectedFeatureSensorBiasPlot.png" style="zoom:100%;" /></p>
<p>图中可以看出，这四种工况模式可以被单个或多个特征区分</p>
</section>
<section>
<p>接下来可以用选定的特征子集，训练一个含有20棵子树的装袋树分类器，来区分这几种传感器偏差故障</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode matlab"><code class="sourceCode matlab"><a class="sourceLine" id="cb91-1" data-line-number="1">rng default <span class="co">% 保证再现性的随机种子</span></a>
<a class="sourceLine" id="cb91-2" data-line-number="2">Mdl = TreeBagger(<span class="fl">20</span>, FeatureTable(I,[J <span class="fl">21</span>]), <span class="st">&#39;Condition&#39;</span>,...</a>
<a class="sourceLine" id="cb91-3" data-line-number="3">   <span class="st">&#39;OOBPrediction&#39;</span>,<span class="st">&#39;on&#39;</span>,...</a>
<a class="sourceLine" id="cb91-4" data-line-number="4">   <span class="st">&#39;OOBPredictorImportance&#39;</span>,<span class="st">&#39;on&#39;</span>);</a>
<a class="sourceLine" id="cb91-5" data-line-number="5">figure</a>
<a class="sourceLine" id="cb91-6" data-line-number="6">plot(oobError(Mdl))</a>
<a class="sourceLine" id="cb91-7" data-line-number="7">xlabel(<span class="st">&#39;Number of trees&#39;</span>)</a>
<a class="sourceLine" id="cb91-8" data-line-number="8">ylabel(<span class="st">&#39;Misclassification probability&#39;</span>)</a></code></pre></div>
<p align=center><img src="..\HIDesign\sensorBiasModel.png" style="zoom:110%;" /></p>
<p>可以看出，最终错分率低于3%，证明可以选择一部分特征子集来区分故障子类（如归属于传感器偏差类的故障）</p>
</section>
<section>
<h4 id="使用classification-learner-app进行多分类"><strong>使用Classification Learner APP进行多分类</strong></h4>
<p>上述部分主要通过人工检测的方式选择特征划分故障类型，这种方法比较原始并且也不一定能覆盖所有的故障类型。一种更时髦的方法是使用Matlab统计和机器学习工具箱中的Classification Learner APP，以便快速建模和比较结果，操作过程如下：</p>
<p><strong>导入数据并定义验证方式（此处选择20%样本留出）</strong></p>
<p align=center><img data-src="..\HIDesign\APP_1.PNG" style="zoom:100%;"/></p>
</section>
<section>
<p><strong>训练并分析结果</strong></p>
<p align=center><img data-src="..\HIDesign\APP_2.PNG" style="zoom:94%;"/></p>
<p>从结果可看出，</p>
<ul>
<li>三次支持向量机具有最好的分类效果，准确率达到了86%</li>
<li>间隙距磨损故障易和叶轮出口沉积故障的识别混淆</li>
<li>物理磨损易和叶片折断和健康状态两种模式混淆，推测可能是跟物理磨损的程度有关，轻微时更像健康状态，严重时更像叶片折断</li>
</ul>
<p>要想导出生成的结果模型，可直接使用“导出”功能</p>
</section>
</section>
<section align=left>
<h4 id="第六步总结"><strong>第六步：总结</strong></h4>
<p>本案例介绍了基于比较测量数据和模型估计得到参数之间残差的方式建模分析离心泵故障的过程。当建模任务教复杂，且模型参数依赖于操作工况时，该方法是对参数估计和基于轨迹方法的很好补充</p>
<p>基于残差的故障诊断方法遵循以下步骤：</p>
<ol type="1">
<li>使用物理知识和黑盒系统识别技术对测量数据和系统输出的动态过程建模</li>
<li>计算测量信号和模型输出信号的残差，该残差在方差较大时可能需要经过平滑化、滤波处理</li>
<li>对每种残差提取残差特征，如峰值、功率、谷值等信号特征</li>
<li>选择可用特征，使用异常检测和分类技术进行故障检测</li>
<li>并不是所有残差和由它导出的特征都对每种故障的识别有效。对特征绘制散点图和柱状图有利于找到哪些特征对哪些特定的故障类型分离有用。对可被用来分离故障的特征挑选和评估过程属于可迭代过程（即可不断优化）</li>
</ol>
</section>
<section>
<p style="font-size:44px;"><strong>参考：</strong><a href="https://ww2.mathworks.cn/help/predmaint/ug/fault-diagnosis-of-centrifugal-pumps-using-residual-analysis.html" target="_blank">https://ww2.mathworks.cn/help/predmaint/ug/fault-diagnosis-of-centrifugal-pumps-using-residual-analysis.html</a></p>
</section>
	    </div>
  </div>

  <script src="../reveal.js/lib/js/head.min.js"></script>
  <script src="../reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: '../reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>